/* eslint-disable @typescript-eslint/no-empty-function */
import { describe, it, expect } from '@jest/globals'
import { StreamServer, IncomingMoney } from '../src'
import { randomBytes } from 'ilp-protocol-stream/dist/src/crypto'
import {
  isIlpReply,
  IlpError,
  IlpReject,
  isValidIlpAddress,
  IlpPrepare,
  deserializeIlpPrepare,
  serializeIlpFulfill,
  serializeIlpReply,
} from 'ilp-packet'
import { base64url, encrypt, hmac, sha256 } from '../src/utils'
import {
  Packet,
  IlpPacketType,
  ConnectionCloseFrame,
  ErrorCode,
  FrameType,
  ConnectionNewAddressFrame,
  StreamReceiptFrame,
} from 'ilp-protocol-stream/dist/src/packet'
import Long from 'long'
import { verifyReceipt } from 'ilp-protocol-stream/dist/src/util/receipt'
import { createConnection } from 'ilp-protocol-stream'
import { Plugin } from 'ilp-protocol-stream/dist/src/util/plugin-interface'
import { serializeIldcpResponse } from 'ilp-protocol-ildcp'

describe('StreamServer', () => {
  const serverAddress = 'g.receiver'
  const serverSecret = randomBytes(32)
  const server = new StreamServer({
    serverAddress,
    serverSecret,
  })

  describe('constructor', () => {
    it('throws if invalid server secret length', () => {
      expect(
        () =>
          new StreamServer({
            serverSecret: randomBytes(31),
            serverAddress: 'g.me',
          })
      ).toThrowError('Server secret must be 32 bytes')
    })

    it('throws if invalid ILP address', () => {
      expect(
        () =>
          new StreamServer({
            serverSecret: randomBytes(32),
            serverAddress: 'foo@example.com',
          })
      ).toThrowError('Invalid server base ILP address')
    })
  })

  describe('#generateCredentials', () => {
    it('generates credentials with no options', () => {
      const credentials = server.generateCredentials()
      expect(isValidIlpAddress(credentials.ilpAddress))
      expect(credentials.sharedSecret.byteLength).toBe(32)
    })

    it('throws if invalid receipt nonce length', () => {
      expect(() =>
        server.generateCredentials({
          receiptSetup: {
            nonce: randomBytes(17),
            secret: randomBytes(32),
          },
        })
      ).toThrowError('Failed to generate credentials: receipt nonce must be 16 bytes')
    })

    it('throws if invalid receipt secret length', () => {
      expect(() =>
        server.generateCredentials({
          receiptSetup: {
            nonce: randomBytes(16),
            secret: Buffer.alloc(0),
          },
        })
      ).toThrowError('Failed to generate credentials: receipt secret must be 32 bytes')
    })

    it('throws if invalid asset scale', () => {
      expect(() => {
        server.generateCredentials({
          asset: {
            scale: 256,
            code: 'USD',
          },
        })
      }).toThrowError('Failed to generate credentials: invalid asset scale')
    })

    it('accepts credentials generated by a different instance', () => {
      const server2 = new StreamServer({
        serverAddress,
        serverSecret,
      })

      const { ilpAddress } = server.generateCredentials({
        paymentTag: 'foo',
      })
      expect(server2.decodePaymentTag(ilpAddress)).toBe('foo')
    })

    it('throws if too much data to encode in address', () => {
      expect(() =>
        server.generateCredentials({
          paymentTag: 'a'.repeat(1023),
        })
      ).toThrow()
    })

    it('throws if generated ILP address is too long', () => {
      const server = new StreamServer({
        serverAddress: 'g.' + 'a'.repeat(1000),
        serverSecret: randomBytes(32),
      })

      // Base server ILP address combined with payment tag exceeds maximum ILP address space
      expect(() =>
        server.generateCredentials({
          paymentTag: '0123456789'.repeat(10),
        })
      ).toThrowError(
        'Failed to generate credentials: too much data to encode within an ILP address'
      )
    })
  })
})

describe('handling packets', () => {
  const serverAddress = 'g.receiver'
  const serverSecret = randomBytes(32)
  const server = new StreamServer({
    serverAddress,
    serverSecret,
  })

  it('rejects if packet is not addressed to receiver', () => {
    const connectionOrReject = server.createReply({
      amount: '0',
      destination: 'g.not_receiver',
      executionCondition: randomBytes(32),
      expiresAt: new Date(),
      data: Buffer.alloc(0),
    }) as IlpReject

    expect(isIlpReply(connectionOrReject))
    expect(connectionOrReject.code).toBe(IlpError.F02_UNREACHABLE)
    expect(connectionOrReject.data.byteLength).toBe(0)
    expect(connectionOrReject.triggeredBy).toBe(serverAddress)
  })

  it('rejects if token fails decryption', () => {
    const connectionOrReject = server.createReply({
      amount: '0',
      destination: 'g.receiver.INVALID',
      executionCondition: randomBytes(32),
      expiresAt: new Date(),
      data: Buffer.alloc(0),
    }) as IlpReject

    expect(isIlpReply(connectionOrReject))
    expect(connectionOrReject.code).toBe(IlpError.F06_UNEXPECTED_PAYMENT)
    expect(connectionOrReject.data.byteLength).toBe(0)
    expect(connectionOrReject.triggeredBy).toBe(serverAddress)
  })

  it('rejects if token is structurally invalid', () => {
    const token = base64url(
      encrypt(hmac(serverSecret, Buffer.from('ilp_stream_connection_token')), Buffer.alloc(0))
    )

    const connectionOrReject = server.createReply({
      amount: '0',
      destination: `g.receiver.${token}`,
      executionCondition: randomBytes(32),
      expiresAt: new Date(),
      data: Buffer.alloc(0),
    }) as IlpReject

    expect(isIlpReply(connectionOrReject))
    expect(connectionOrReject.code).toBe(IlpError.F06_UNEXPECTED_PAYMENT)
    expect(connectionOrReject.data.byteLength).toBe(0)
    expect(connectionOrReject.triggeredBy).toBe(serverAddress)
  })

  it('supports payment tag', () => {
    const paymentTag = 'Hello world!'
    const { ilpAddress: address1 } = server.generateCredentials({
      paymentTag,
    })
    expect(server.decodePaymentTag(address1)).toBe(paymentTag)

    const { ilpAddress: address2 } = server.generateCredentials()
    expect(server.decodePaymentTag(address2)).toBeUndefined()
  })

  it('rejects if STREAM packet fails decryption', () => {
    const { ilpAddress } = server.generateCredentials()
    const prepare: IlpPrepare = {
      destination: ilpAddress,
      executionCondition: randomBytes(32),
      amount: '10',
      expiresAt: new Date(),
      data: randomBytes(100),
    }

    const reply = server.createReply(prepare) as IlpReject

    expect(isIlpReply(reply))
    expect(reply.code).toBe(IlpError.F06_UNEXPECTED_PAYMENT)
    expect(reply.data.byteLength).toBe(0)
    expect(reply.triggeredBy).toBe(serverAddress)
  })

  it('rejects if STREAM packet is structurally invalid', () => {
    const { sharedSecret, ilpAddress } = server.generateCredentials()
    const data = encrypt(hmac(sharedSecret, Buffer.from('ilp_stream_encryption')), Buffer.alloc(0))

    const prepare: IlpPrepare = {
      amount: '0',
      destination: ilpAddress,
      executionCondition: randomBytes(32),
      expiresAt: new Date(),
      data,
    }

    const reply = server.createReply(prepare) as IlpReject

    expect(isIlpReply(reply))
    expect(reply.code).toBe(IlpError.F06_UNEXPECTED_PAYMENT)
    expect(reply.data.byteLength).toBe(0)
    expect(reply.triggeredBy).toBe(serverAddress)
  })

  it('rejects if STREAM packet type is not Prepare', async () => {
    const { sharedSecret, ilpAddress } = server.generateCredentials()

    const key = hmac(sharedSecret, Buffer.from('ilp_stream_encryption'))
    const data = await new Packet(1, IlpPacketType.Fulfill, 0).serializeAndEncrypt(key)

    const prepare: IlpPrepare = {
      amount: '0',
      destination: ilpAddress,
      executionCondition: Buffer.alloc(32),
      expiresAt: new Date(),
      data,
    }

    const reply = server.createReply(prepare) as IlpReject

    expect(isIlpReply(reply))
    expect(reply.code).toBe(IlpError.F00_BAD_REQUEST)
    expect(reply.data.byteLength).toBe(0)
    expect(reply.triggeredBy).toBe(serverAddress)
  })

  it('handles connection close frames', async () => {
    const { sharedSecret, ilpAddress } = server.generateCredentials()

    const key = hmac(sharedSecret, Buffer.from('ilp_stream_encryption'))
    const data = await new Packet(1, IlpPacketType.Prepare, 0, [
      new ConnectionCloseFrame(ErrorCode.NoError, ''),
    ]).serializeAndEncrypt(key)

    const prepare: IlpPrepare = {
      amount: '0',
      destination: ilpAddress,
      executionCondition: Buffer.alloc(32),
      expiresAt: new Date(),
      data,
    }

    const reply = server.createReply(prepare) as IlpReject

    expect(isIlpReply(reply))
    expect(reply.code).toBe(IlpError.F99_APPLICATION_ERROR)
    expect(reply.triggeredBy).toBe(serverAddress)

    // Includes reply packet with echoed ConnectionClose frame
    const replyPacket = await Packet.decryptAndDeserialize(key, reply.data)
    expect(replyPacket.frames.some((f) => f.type === FrameType.ConnectionClose))
    expect(replyPacket.sequence).toEqual(Long.UONE)
    expect(replyPacket.prepareAmount).toEqual(Long.UZERO)
  })

  it('replies with asset details', async () => {
    const { sharedSecret, ilpAddress } = server.generateCredentials({
      asset: {
        code: 'USD',
        scale: 4,
      },
    })

    const key = hmac(sharedSecret, Buffer.from('ilp_stream_encryption'))
    const data = await new Packet(0, IlpPacketType.Prepare, 1, [
      new ConnectionNewAddressFrame('g.sender'),
    ]).serializeAndEncrypt(key)

    const prepare: IlpPrepare = {
      amount: '0',
      destination: ilpAddress,
      executionCondition: Buffer.alloc(32),
      expiresAt: new Date(),
      data,
    }

    const reply = server.createReply(prepare) as IlpReject

    expect(isIlpReply(reply))
    expect(reply.code).toBe(IlpError.F99_APPLICATION_ERROR)
    expect(reply.triggeredBy).toBe(serverAddress)

    // Includes reply packet with echoed ConnectionClose frame
    const replyPacket = await Packet.decryptAndDeserialize(key, reply.data)
    expect(
      replyPacket.frames.some(
        (f) =>
          f.type === FrameType.ConnectionAssetDetails &&
          f.sourceAssetCode === 'USD' &&
          f.sourceAssetScale === 4
      )
    )
    expect(replyPacket.sequence).toEqual(Long.UZERO)
    expect(replyPacket.prepareAmount).toEqual(Long.UZERO)
  })

  it('rejects if exchange rate is insufficient', async () => {
    const { sharedSecret, ilpAddress } = server.generateCredentials()

    const key = hmac(sharedSecret, Buffer.from('ilp_stream_encryption'))
    const data = await new Packet(1, IlpPacketType.Prepare, 2).serializeAndEncrypt(key)

    const prepare: IlpPrepare = {
      amount: '1', // Received 1 unit, but minimum is 2
      destination: ilpAddress,
      executionCondition: Buffer.alloc(32),
      expiresAt: new Date(),
      data,
    }

    const reply = server.createReply(prepare) as IlpReject

    expect(isIlpReply(reply))
    expect(reply.code).toBe(IlpError.F99_APPLICATION_ERROR)
    expect(reply.triggeredBy).toBe(serverAddress)

    const replyPacket = await Packet.decryptAndDeserialize(key, reply.data)
    expect(replyPacket.sequence).toEqual(Long.UONE)
    expect(replyPacket.prepareAmount).toEqual(Long.UONE)
  })

  it('rejects if packet is unfulfillable', async () => {
    const { sharedSecret, ilpAddress } = server.generateCredentials()

    const key = hmac(sharedSecret, Buffer.from('ilp_stream_encryption'))
    const data = await new Packet(23, IlpPacketType.Prepare, 0).serializeAndEncrypt(key)

    const prepare: IlpPrepare = {
      amount: '1',
      destination: ilpAddress,
      executionCondition: randomBytes(32),
      expiresAt: new Date(),
      data,
    }

    const reply = server.createReply(prepare) as IlpReject

    expect(isIlpReply(reply))
    expect(reply.code).toBe(IlpError.F99_APPLICATION_ERROR)
    expect(reply.triggeredBy).toBe(serverAddress)

    const replyPacket = await Packet.decryptAndDeserialize(key, reply.data)
    expect(+replyPacket.sequence).toBe(23)
    expect(+replyPacket.prepareAmount).toBe(1)
  })

  it('generates receipts using total received', async () => {
    const receiptNonce = randomBytes(16)
    const receiptSecret = randomBytes(32)
    const { sharedSecret, ilpAddress } = server.generateCredentials({
      receiptSetup: {
        nonce: receiptNonce,
        secret: receiptSecret,
      },
    })

    const key = hmac(sharedSecret, Buffer.from('ilp_stream_encryption'))
    const data = await new Packet(1, IlpPacketType.Prepare, 1).serializeAndEncrypt(key)

    const fulfillmentKey = hmac(sharedSecret, Buffer.from('ilp_stream_fulfillment'))
    const fulfillment = hmac(fulfillmentKey, data)
    const executionCondition = sha256(fulfillment)

    const prepare: IlpPrepare = {
      amount: '1', // This also tests packets with received amount = minimum
      destination: ilpAddress,
      executionCondition,
      expiresAt: new Date(),
      data,
    }

    const money = server.createReply(prepare) as IncomingMoney
    money.setTotalReceived(9)
    const reply = money.temporaryDecline()

    expect(isIlpReply(reply))
    expect(reply.code).toBe(IlpError.T00_INTERNAL_ERROR)
    expect(reply.triggeredBy).toBe(serverAddress)

    const replyPacket = await Packet.decryptAndDeserialize(key, reply.data)
    expect(+replyPacket.sequence).toBe(1)
    expect(+replyPacket.prepareAmount).toBe(1)

    const receiptFrame = replyPacket.frames.find(
      (f) => f.type === FrameType.StreamReceipt
    ) as StreamReceiptFrame

    expect(receiptFrame).toBeDefined()
    expect(+receiptFrame.streamId).toBe(1)

    const receipt = verifyReceipt(receiptFrame.receipt, receiptSecret)
    expect(receipt.nonce).toEqual(receiptNonce)
    expect(+receipt.streamId).toBe(1)
    expect(+receipt.totalReceived).toBe(9)
    expect(receipt.version).toBe(1)
  })

  it('creates Fulfill if accepted', async () => {
    const { sharedSecret, ilpAddress } = server.generateCredentials()

    const key = hmac(sharedSecret, Buffer.from('ilp_stream_encryption'))
    const data = await new Packet(100, IlpPacketType.Prepare, 50).serializeAndEncrypt(key)

    const fulfillmentKey = hmac(sharedSecret, Buffer.from('ilp_stream_fulfillment'))
    const fulfillment = hmac(fulfillmentKey, data)
    const executionCondition = sha256(fulfillment)

    const prepare: IlpPrepare = {
      amount: '1000',
      destination: ilpAddress + '.extra.segments',
      executionCondition,
      expiresAt: new Date(),
      data,
    }

    const money = server.createReply(prepare) as IncomingMoney
    money.setTotalReceived(1000) // Should do nothing since there was no receipt setup parameters
    const reply = money.accept()

    expect(reply.fulfillment).toEqual(fulfillment)

    const replyPacket = await Packet.decryptAndDeserialize(key, reply.data)
    expect(+replyPacket.sequence).toBe(100)
    expect(+replyPacket.prepareAmount).toBe(1000)
    expect(replyPacket.frames.length).toBe(0) // No `StreamReceipt` frame
  })

  it('creates Reject if soft declined', async () => {
    const { sharedSecret, ilpAddress } = server.generateCredentials()

    const key = hmac(sharedSecret, Buffer.from('ilp_stream_encryption'))
    const data = await new Packet(1, IlpPacketType.Prepare, 2).serializeAndEncrypt(key)

    const fulfillmentKey = hmac(sharedSecret, Buffer.from('ilp_stream_fulfillment'))
    const fulfillment = hmac(fulfillmentKey, data)
    const executionCondition = sha256(fulfillment)

    const prepare: IlpPrepare = {
      amount: '3',
      destination: ilpAddress + '.extra.segments',
      executionCondition,
      expiresAt: new Date(),
      data,
    }

    const money = server.createReply(prepare) as IncomingMoney
    const reply = money.temporaryDecline()

    expect(reply.code).toBe(IlpError.T00_INTERNAL_ERROR)
    expect(reply.triggeredBy).toBe(serverAddress)
    expect(reply.message).toBe('')

    const replyPacket = await Packet.decryptAndDeserialize(key, reply.data)
    expect(+replyPacket.sequence).toBe(1)
    expect(+replyPacket.prepareAmount).toBe(3)
    expect(replyPacket.frames.length).toBe(0)
  })

  it('creates Reject if hard declined', async () => {
    const { sharedSecret, ilpAddress } = server.generateCredentials()

    const key = hmac(sharedSecret, Buffer.from('ilp_stream_encryption'))
    const data = await new Packet(1, IlpPacketType.Prepare, 2).serializeAndEncrypt(key)

    const fulfillmentKey = hmac(sharedSecret, Buffer.from('ilp_stream_fulfillment'))
    const fulfillment = hmac(fulfillmentKey, data)
    const executionCondition = sha256(fulfillment)

    const prepare: IlpPrepare = {
      amount: '3',
      destination: ilpAddress,
      executionCondition,
      expiresAt: new Date(),
      data,
    }

    const money = server.createReply(prepare) as IncomingMoney
    const reply = money.finalDecline()

    expect(reply.code).toBe(IlpError.F99_APPLICATION_ERROR)
    expect(reply.triggeredBy).toBe(serverAddress)
    expect(reply.message).toBe('')

    const replyPacket = await Packet.decryptAndDeserialize(key, reply.data)
    expect(+replyPacket.sequence).toBe(1)
    expect(+replyPacket.prepareAmount).toBe(3)
    expect(replyPacket.frames.some((f) => f.type === FrameType.ConnectionClose))
  })

  it('exposes unique connection ids', async () => {
    const generateConnectionId = async (): Promise<string> => {
      const { ilpAddress, sharedSecret } = server.generateCredentials()

      const key = hmac(sharedSecret, Buffer.from('ilp_stream_encryption'))
      const data = await new Packet(1, IlpPacketType.Prepare, 2).serializeAndEncrypt(key)

      const fulfillmentKey = hmac(sharedSecret, Buffer.from('ilp_stream_fulfillment'))
      const fulfillment = hmac(fulfillmentKey, data)
      const executionCondition = sha256(fulfillment)

      const { connectionId } = server.createReply({
        amount: '3',
        destination: ilpAddress,
        executionCondition,
        expiresAt: new Date(),
        data,
      }) as IncomingMoney

      return connectionId
    }

    const id1 = await generateConnectionId()
    const id2 = await generateConnectionId()
    expect(id2).not.toBe(id1)
  })
})

describe('ilp-protocol-stream integration', () => {
  it('accepts incoming payments', async () => {
    const receiptNonce = randomBytes(16)
    const receiptSecret = randomBytes(32)
    const server = new StreamServer({
      serverAddress: 'test.wallet',
      serverSecret: randomBytes(32),
    })

    const { sharedSecret, ilpAddress } = server.generateCredentials({
      paymentTag: 'some random information.',
      receiptSetup: {
        nonce: receiptNonce,
        secret: receiptSecret,
      },
      asset: {
        code: 'JPY',
        scale: 6,
      },
    })

    let replyToIldcp = true
    const plugin: Plugin = {
      async sendData(data: Buffer) {
        // First, handle the initial IL-DCP request when the connection is created
        if (replyToIldcp) {
          replyToIldcp = false
          return serializeIldcpResponse({
            clientAddress: 'test.wallet',
            assetCode: 'USD',
            assetScale: 4,
          })
        }
        // Otherwise, handle the packet using the STREAM server
        else {
          const prepare = deserializeIlpPrepare(data)
          const moneyOrReject = server.createReply(prepare)
          if (isIlpReply(moneyOrReject)) {
            return serializeIlpReply(moneyOrReject)
          }

          moneyOrReject.setTotalReceived(prepare.amount)
          return serializeIlpFulfill(moneyOrReject.accept())
        }
      },
      async connect() {},
      async disconnect() {},
      isConnected() {
        return true
      },
      registerDataHandler() {},
      deregisterDataHandler() {},
    }

    const connection = await createConnection({
      plugin,
      sharedSecret,
      destinationAccount: ilpAddress,
    })

    const stream1 = connection.createStream()
    const stream2 = connection.createStream()

    await Promise.all([stream1.sendTotal(2003), stream2.sendTotal(1000)])

    stream1.end()
    stream2.end()

    await connection.end()

    expect(+connection.totalDelivered).toBe(3003)
    expect(stream1.receipt).toBeDefined()
    expect(connection.destinationAssetCode).toBe('JPY')
    expect(connection.destinationAssetScale).toBe(6)
  })
})
